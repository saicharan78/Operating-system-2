Software engineering Report

General Approach to the problem

-The total simulation of the project is divided into five modules. The five modules are CPU,ErrorHandler,Memory,scheduler and disk manager.
-To understand the execution flow of the simulation, a flow chart was designed.
-The execution starts with the system needing to call the loader.
-The user job is divided in to pages and then loaded in to memory.
-The memory is also divided into frames and the user pages are loaded into frames.
-The loader continues to load user job till the frame count reaches the (number of pages required by the job)/3 or 2 pages which ever is minimum.
-After that the pages are loaded into disk,for which the disk manager is involved.
-For convinience the diskmanager also uses paging. Frames and pages are of same memory size.
-The user job is then added to the first level subqueue (in MultiLevel feedback queue) by loader.
-If no more jobs can be loaded in to the memory. Then the control is tranferred to the scheduler.
-The scheduler uses multiLevel Feedback queues for scheduling.
-There are four subqueues namely subqueue-1 to subqueue-4.
-Initially the process will be loaded into the first subqueue.
-Then based on the resident rules of each subqueue the migration to other subqueues take place.
-The resident rules of each queue is, when a time quantum expires and the number of turns exceed the limit of the subqueue residece limit 
then the process will be trasferred to the next subqueue.
- when a time quantum expires and the number of turns do not exceed the limit of the subqueue residece limit 
then the process will reside on the same subqueue.
-When an IO request is made the process number of turns will be made to zero and the process remains in the same subqueue.
-When the process resides in 4th subqueue and makes an io request then the process will be moved to the first subqueue .
-and if the process resides in the 4th subqueue longer than  time then it will be moved to the first subqueue inorder to avoid startvation.
-Then the subqueues are processed by the scheduler.
-Then the control shifts to the CPU.
-If the user job executes halt instruction then the job is spooled out from the memory and loader is called.
-The diskmanager is involved when we need demand paging.When an instruction is not in memory the diskmanager is called and a page fault is generated.
-As, specified above the diskmanager uses paging scheme to manage the diskspace.
-Paging is easier because the user page size and frame size are equal, this makes the keeping track of disk space easier.
-For page replacement first in first out strategy is used.
-When a tie breaker occurs while replacing a page, the first element in the queue is replaced.
-If any errors occurs in the program the appropritate error message or warning is generated by the error handler.
-If the error is fatal the job is spooled from the memory.
-The same execution flow iterates for 12 times to generate the migrations matrix for time quantums {35,40,45,50} and Cputurns {3,4,5}.
-The matrix is included in the report.

-The migrations matrix is for tb+err:
     35   40   45   50
   3 716  696 667  632
   4 644  598 586  576
   5 584  570 564  560   
-The migrations matrix is for tb is:
  35  40  45  50
3 731 698 689 670
4 655 632 597 582
5 583 569 565 558

-From the matrix we can observe that the number of migrations decrease when the time quantum is more,
 also when we increase the number of cpu turns for each process the number of migrations decrease.

  Bulk complexities 
  
  Number of lines:2531
  Number of blank lines:103
  Number of nonblank lines:1694
  Number of comment lines:151
  Number of conditional statements:279
  Number of classes:7 
  Number of functions:48
  
  Work break down:
  
  Design:5 days
  Coding:6 days
  Testing:9 days
  Documentation:1
  
  compatability with other operating systems
  
  -As I have used java programming for my simulation it can be deployed on any operating system. 
  Because JVM is available on every operating system, the simulation is independent of operating system.
  
  reason for language
  
  -I have chosen java because of its wide range of libraries which can be used readily. 
  -There are lot of in built functions which can reduce the length of code and debugging is easier in java.